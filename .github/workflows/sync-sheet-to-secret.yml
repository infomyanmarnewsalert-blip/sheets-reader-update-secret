name: Sync Google Sheet to GitHub Secret (Hub A -> Target B)

on:
  workflow_dispatch: {}   # 手動実行
  repository_dispatch:
    types: [sheet_updated]   # ← 追加

permissions:
  contents: read
  actions: write   # ← 追加：古いスナップショット削除に必要

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: false

jobs:
  sync:
    runs-on: ubuntu-latest

    steps:
      # ✅ gh はプリインストールなので不要
      # - name: Install gh CLI
      #   uses: cli/gh-action@v2

      - name: Show gh version (debug)
        run: gh --version

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install deps
        run: |
          python -m pip install --upgrade pip
          pip install gspread google-auth

      - name: Read all emails from Sheet1!A:A (comma-joined)
        id: read
        env:
          GOOGLE_CREDENTIALS: ${{ secrets.GOOGLE_CREDENTIALS }}
          SHEET_ID:    ${{ github.event.client_payload.sheet_id    || secrets.SHEET_ID }}
          SHEET_RANGE: ${{ github.event.client_payload.sheet_range || 'emails!A:A' }}
        run: |
          python - <<'PY'
          import os, json
          import gspread
          from google.oauth2.service_account import Credentials

          creds_info = json.loads(os.environ["GOOGLE_CREDENTIALS"])
          scopes = ["https://www.googleapis.com/auth/spreadsheets.readonly"]
          creds = Credentials.from_service_account_info(creds_info, scopes=scopes)
          gc = gspread.authorize(creds)

          sh = gc.open_by_key(os.environ["SHEET_ID"])
          rng = os.environ.get("SHEET_RANGE", "emails!A:A")

          if "!" in rng:
              ws_name, cell_range = rng.split("!", 1)
              ws = sh.worksheet(ws_name)
          else:
              ws = sh.sheet1
              cell_range = rng

          values = ws.get(cell_range)  # [[val1],[val2],...]
          emails = [row[0].strip() for row in values if row and row[0].strip()]

          joined = ",".join(emails)
          with open("secret_value.txt", "wb") as f:
              f.write(joined.encode("utf-8"))
          PY

      - name: Update Secret in TARGET repo (B, environment-scoped)
        env:
          GH_TOKEN: ${{ secrets.PAT_FOR_SECRETS }}  # gh が使うトークン（BのSecrets RW権限）
          # 既定は production。payloadがあれば上書き
          ENV_NAME: ${{ github.event.client_payload.target_env || secrets.TARGET_ENV || 'production' }}
          TARGET_OWNER: ${{ github.event.client_payload.target_owner || secrets.TARGET_OWNER || github.repository_owner }}
          TARGET_REPO:  ${{ github.event.client_payload.target_repo  || secrets.TARGET_REPO  }}
          SECRET_NAME:  ${{ github.event.client_payload.secret_name  || secrets.SECRET_NAME  }}
        run: |
          test -n "$TARGET_REPO" || { echo "TARGET_REPO is empty"; exit 1; }
          test -n "$SECRET_NAME" || { echo "SECRET_NAME is empty"; exit 1; }
          test -n "$ENV_NAME"    || { echo "ENV_NAME is empty"; exit 1; }

          # gh は既に入っている。環境スコープのSecretを更新
          cat secret_value.txt | gh secret set "$SECRET_NAME" \
            --env "$ENV_NAME" \
            -R "$TARGET_OWNER/$TARGET_REPO"

      # ===== ここから追加：最新スナップショットだけ保持 =====

      - name: Build emails.txt (normalized list for snapshot)
        run: |
          # secret_value.txt を 1行1メールへ変換し、trim → lowercase → unique → sort
          tr ',' '\n' < secret_value.txt \
          | sed 's/^[ \t]*//;s/[ \t]*$//' \
          | awk 'NF' \
          | awk '{print tolower($0)}' \
          | sort -u > emails.txt

      - name: Upload snapshot with run number (keep for diff)
        uses: actions/upload-artifact@v4
        with:
          name: emails-snapshot-${{ github.run_number }}
          path: emails.txt
          if-no-files-found: error
          retention-days: 90   # 最新1つだけ残す前提で、保持は長めに

      - name: Install jq for cleanup
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq

      - name: Cleanup old snapshots (keep only current)
        env:
          GH_TOKEN: ${{ github.token }}   # actions:write 権限が必要
          REPO: ${{ github.repository }}
          CUR_RUN: ${{ github.run_number }}
        run: |
          set -euo pipefail
          cur_name="emails-snapshot-${CUR_RUN}"
          echo "Start cleanup: keep only ${cur_name}"

          # 全ページ取得 (--paginate)。再帰で name/id を持つオブジェクトだけ拾うので安全。
          gh api -H 'Accept: application/vnd.github+json' \
                 --paginate \
                 "/repos/${REPO}/actions/artifacts?per_page=100" \
          | jq -r --arg cur "$cur_name" '
              ..                                  # 再帰的に走査
              | objects                           # オブジェクトだけ通す
              | select(has("name") and has("id")) # name と id を持つものだけ
              | select(.name | type=="string")    # name が文字列のものだけ
              | select(.name | startswith("emails-snapshot-") and . != $cur)
              | .id
            ' \
          | while read -r id; do
              [ -z "${id:-}" ] && continue
              echo "Deleting artifact id=${id}"
              # 既に消されていても続行できるようにエラーは握り潰す
              gh api -X DELETE -H 'Accept: application/vnd.github+json' \
                "/repos/${REPO}/actions/artifacts/${id}" || true
            done

          echo "Cleanup complete. Kept: ${cur_name}"

  notify:
    name: Slack notify (diff on success, logs on failure)
    runs-on: ubuntu-latest
    needs: sync
    if: always()  # 成否に関わらず通知
    steps:
      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq unzip coreutils

      - name: Download CURRENT snapshot (this run)
        uses: actions/download-artifact@v4
        with:
          name: emails-snapshot-${{ github.run_number }}
          path: current

      - name: Fetch PREVIOUS snapshot (most recent, excluding current)
        id: prev
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          CUR_RUN: ${{ github.run_number }}
        run: |
          set -euo pipefail
          cur_name="emails-snapshot-${CUR_RUN}"
          json="$(gh api -H 'Accept: application/vnd.github+json' --paginate "/repos/${REPO}/actions/artifacts?per_page=100")"
          prev_id=$(printf '%s\n' "$json" \
            | jq -s -r --arg cur "$cur_name" '
                map(select(type=="object" and has("artifacts")))
                | map(.artifacts) | add
                | map(select(.name|startswith("emails-snapshot-") and .name!=$cur))
                | sort_by(.created_at) | reverse
                | (.[0].id // empty)
              ')
          if [ -z "${prev_id:-}" ]; then
            echo "has_prev=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi
          echo "has_prev=true" >> "$GITHUB_OUTPUT"
          mkdir -p prev
          gh api -H 'Accept: application/vnd.github+json' \
            "/repos/${REPO}/actions/artifacts/${prev_id}/zip" > prev.zip
          unzip -o prev.zip -d prev >/dev/null

      - name: Compute diff (added / removed)
        id: diff
        run: |
          set -euo pipefail
          CUR="current/emails.txt"
          PREV="prev/emails.txt"

          if [ ! -f "$CUR" ]; then
            echo "current emails.txt not found"; exit 1
          fi

          sort -u "$CUR" -o "$CUR"
          if [ -f "$PREV" ]; then
            sort -u "$PREV" -o "$PREV"
            comm -23 "$CUR" "$PREV" > added.txt
            comm -13 "$CUR" "$PREV" > removed.txt
          else
            cp "$CUR" added.txt
            : > removed.txt
          fi

          echo "added=$(wc -l < added.txt)"     >> "$GITHUB_OUTPUT"
          echo "removed=$(wc -l < removed.txt)" >> "$GITHUB_OUTPUT"
          echo "count=$(wc -l < "$CUR")"        >> "$GITHUB_OUTPUT"
          echo "done=true"                      >> "$GITHUB_OUTPUT"

      # ▼ 失敗時は実ログを取得して貼る
      - name: Fetch workflow logs (only on failure)
        if: needs.sync.result != 'success'
        id: logs
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          gh api -H 'Accept: application/vnd.github+json' \
            "/repos/${REPO}/actions/runs/${{ github.run_id }}/logs" > logs.zip
          mkdir -p logs && unzip -o logs.zip -d logs >/dev/null || true
          # すべての *.txt を結合し、末尾35,000文字に丸めてSlackに貼る
          find logs -type f -name '*.txt' -print0 | xargs -0 cat > full_logs.txt || true
          tail -c 35000 full_logs.txt > logs_tail.txt || true
          echo "logfile=logs_tail.txt" >> "$GITHUB_OUTPUT"

      - name: Prepare Slack payload
        id: payload
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          CLIENT_PAYLOAD: ${{ toJson(github.event.client_payload) }}
        run: |
          set -euo pipefail
          test -n "${SLACK_WEBHOOK_URL:-}" || { echo "SLACK_WEBHOOK_URL is empty"; exit 1; }

          STATUS="${{ needs.sync.result }}"
          REPO="${{ github.repository }}"
          RUN="#${{ github.run_number }}"
          URL="https://github.com/${REPO}/actions/runs/${{ github.run_id }}"
          EVENT="${{ github.event_name }}"

          # まず GAS からの差分を試す（repository_dispatch のとき）
          has_gas_diff="false"
          if [ "$EVENT" = "repository_dispatch" ] && [ -n "${CLIENT_PAYLOAD:-}" ]; then
            # 追加/削除配列を抽出（無い場合は空配列）
            ADDED_LIST="$(printf '%s' "$CLIENT_PAYLOAD" | jq -r '.added_emails // [] | .[:50] | join("\n")')"
            REMOVED_LIST="$(printf '%s' "$CLIENT_PAYLOAD" | jq -r '.removed_emails // [] | .[:50] | join("\n")')"
            ADDED_CNT="$(printf '%s' "$CLIENT_PAYLOAD" | jq -r '(.added_emails // []) | length')"
            REMOVED_CNT="$(printf '%s' "$CLIENT_PAYLOAD" | jq -r '(.removed_emails // []) | length')"
            COUNT="$(printf '%s' "$CLIENT_PAYLOAD" | jq -r '(.total_count // 0)')"

            # いずれかに要素があれば GAS 差分ありとみなす
            if [ "$ADDED_CNT" != "0" ] || [ "$REMOVED_CNT" != "0" ]; then
              has_gas_diff="true"
            fi
          fi

          if [ "$STATUS" = "success" ]; then
            if [ "$has_gas_diff" = "true" ]; then
              # ✅ GAS 由来の差分を通知
              jq -n \
                --arg t "✅ *SUCCESS* — ${REPO} ${RUN}\n*Total:* ${COUNT}\n*Added:* ${ADDED_CNT}  *Removed:* ${REMOVED_CNT}" \
                --arg added "$ADDED_LIST" \
                --arg removed "$REMOVED_LIST" \
                '{
                  blocks: [
                    {type:"section", text:{type:"mrkdwn", text:$t}},
                    {type:"divider"},
                    {type:"section", fields:[
                      {type:"mrkdwn", text:"*Added (from GAS)*\n```"+$added+"```"},
                      {type:"mrkdwn", text:"*Removed (from GAS)*\n```"+$removed+"```"}
                    ]}
                  ]
                }' > payload.json
            else
              # ↩︎ fallback: 従来のスナップショット差分（既存ステップで added.txt / removed.txt を作っている前提）
              fmt() {
                local file="$1"
                if [ -s "$file" ]; then
                  head -n 50 "$file"
                  local n="$(wc -l < "$file")"
                  [ "$n" -gt 50 ] && echo "... and $((n-50)) more"
                else
                  echo "(none)"
                fi
              }
              ADDED_CNT="${{ steps.diff.outputs.added || '0' }}"
              REMOVED_CNT="${{ steps.diff.outputs.removed || '0' }}"
              COUNT="${{ steps.diff.outputs.count || '0' }}"
              ADDED_LIST="$(fmt added.txt)"
              REMOVED_LIST="$(fmt removed.txt)"

              jq -n \
                --arg t "✅ *SUCCESS* — ${REPO} ${RUN}\n*Total:* ${COUNT}\n*Added:* ${ADDED_CNT}  *Removed:* ${REMOVED_CNT}" \
                --arg added "$ADDED_LIST" \
                --arg removed "$REMOVED_LIST" \
                '{
                  blocks: [
                    {type:"section", text:{type:"mrkdwn", text:$t}},
                    {type:"divider"},
                    {type:"section", fields:[
                      {type:"mrkdwn", text:"*Added (snapshot)*\n```"+$added+"```"},
                      {type:"mrkdwn", text:"*Removed (snapshot)*\n```"+$removed+"```"}
                    ]}
                  ]
                }' > payload.json
            fi
          else
            # 失敗時は既存どおりログ本文を貼る（あなたの現行 notify の failure ブロックを流用）
            jq -n --rawfile log "${{ steps.logs.outputs.logfile }}" \
              --arg t "❌ *FAILURE* — ${REPO} ${RUN}\n*Logs (tail)*:" \
              '{
                blocks: [
                  {type:"section", text:{type:"mrkdwn", text:$t}},
                  {type:"section", text:{type:"mrkdwn", text:"```"+$log+"```"}}
                ]
              }' > payload.json
          fi

          echo "ok=1" >> "$GITHUB_OUTPUT"

      - name: Send to Slack
        if: steps.payload.outputs.ok == '1'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          set -euo pipefail
          resp=$(curl -sS -w "\n%{http_code}" -X POST -H 'Content-type: application/json' \
                   --data @payload.json "$SLACK_WEBHOOK_URL")
          body="${resp%$'\n'*}"
          code="${resp##*$'\n'}"
          echo "HTTP $code"
          echo "Response body: $body"
          [ "$code" = "200" ] && [ "$body" = "ok" ]
